import rclpy
from rclpy.node import Node
from sensor_msgs.msg import Image
from geometry_msgs.msg import Point
from std_msgs.msg import String, Float32
from cv_bridge import CvBridge

import torch
import numpy as np
import cv2
import matplotlib.pyplot as plt

# Replace with your VLPart model import path
from vlpart import build_vlpart_model  # Example placeholder — adjust to actual API

class VLPartNode(Node):
    def __init__(self):
        super().__init__("vlpart_node")

        # --- Core state ---
        self.bridge = CvBridge()
        self.image = None
        self.gaze_point = None

        # --- ROS interfaces ---
        self.create_subscription(Image, "/sam/cropped_image", self.image_cb, 10)
        self.create_subscription(Point, "/sam/gaze_point", self.gaze_cb, 10)

        self.part_label_pub = self.create_publisher(String, "/vlpart/gazed_part", 10)
        self.part_conf_pub = self.create_publisher(Float32, "/vlpart/part_confidence", 10)
        self.part_mask_pub = self.create_publisher(Image, "/vlpart/part_mask", 10)

        # --- Load VLPart (CLIP integrated) ---
        self.get_logger().info("Loading VLPart model (with CLIP backbone)...")
        self.device = "cuda" if torch.cuda.is_available() else "cpu"
        self.vlpart = build_vlpart_model(pretrained=True, device=self.device)
        self.vlpart.eval()
        self.get_logger().info("VLPart ready.")

    # ---------------------------------------------------------
    def image_cb(self, msg: Image):
        self.image = self.bridge.imgmsg_to_cv2(msg, "rgb8")
        self.try_infer()

    def gaze_cb(self, msg: Point):
        self.gaze_point = (int(msg.x), int(msg.y))
        self.try_infer()

    # ---------------------------------------------------------
    def try_infer(self):
        """Run VLPart only when both image and gaze are available."""
        if self.image is None or self.gaze_point is None:
            return

        gaze_x, gaze_y = self.gaze_point
        image = self.image.copy()
        h, w, _ = image.shape

        if not (0 <= gaze_x < w and 0 <= gaze_y < h):
            self.get_logger().warn(f"Gaze point ({gaze_x}, {gaze_y}) outside image bounds")
            return

        self.get_logger().info(f"Running VLPart inference (gaze={self.gaze_point})...")

        # Run VLPart — replace with actual API call from the repo
        # Expected return: dict with "part_names", "part_masks", "scores"
        with torch.no_grad():
            results = self.vlpart.predict(image)  # adjust based on your repo

        if results is None or "part_names" not in results:
            self.get_logger().warn("VLPart returned no results.")
            return

        part_names = results["part_names"]
        part_masks = results["part_masks"]
        scores = results.get("scores", [1.0] * len(part_names))

        gazed_part, gazed_mask, conf = self.find_gazed_part(part_names, part_masks, scores, gaze_x, gaze_y)

        if gazed_part is None:
            self.get_logger().info("Gaze not on any predicted part.")
            return

        # --- Publish results ---
        self.part_label_pub.publish(String(data=gazed_part))
        self.part_conf_pub.publish(Float32(data=float(conf)))

        mask_img = (gazed_mask.astype(np.uint8) * 255)
        mask_msg = self.bridge.cv2_to_imgmsg(mask_img, encoding="mono8")
        self.part_mask_pub.publish(mask_msg)

        self.get_logger().info(f"Gaze on part: {gazed_part} (conf={conf:.3f})")

        # Optional visualization
        overlay = image.copy()
        overlay[gazed_mask > 0] = [255, 0, 0]
        plt.imshow(overlay)
        plt.scatter([gaze_x], [gaze_y], color="yellow", s=50)
        plt.title(f"Gaze → {gazed_part} ({conf:.2f})")
        plt.axis("off")
        plt.show(block=False)
        plt.pause(2)
        plt.close()

        # Reset
        self.image = None
        self.gaze_point = None

    # ---------------------------------------------------------
    def find_gazed_part(self, names, masks, scores, gx, gy):
        """Return part name/mask/confidence that contains the gaze."""
        for name, mask, score in zip(names, masks, scores):
            if mask[int(gy), int(gx)] > 0:
                return name, mask, score

        # Optional fallback: nearest part
        best_name, best_mask, best_dist, best_score = None, None, float("inf"), 0.0
        for name, mask, score in zip(names, masks, scores):
            ys, xs = np.where(mask > 0)
            if len(xs) == 0: continue
            dist = np.min(np.sqrt((xs - gx) ** 2 + (ys - gy) ** 2))
            if dist < best_dist:
                best_dist, best_name, best_mask, best_score = dist, name, mask, score

        if best_name:
            self.get_logger().info(f"Gaze near part: {best_name} (distance={best_dist:.1f})")
        return best_name, best_mask, best_score


def main(args=None):
    rclpy.init(args=args)
    node = VLPartGazeNode()
    rclpy.spin(node)
    node.destroy_node()
    rclpy.shutdown()


if __name__ == "__main__":
    main()